<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","volume","src","core_lib.rs"],"content":"use im::Vector;\r\n\r\nuse crate::value::{Scope, Value};\r\n\r\n#[derive(Debug, Eq, PartialEq, Copy, Clone)]\r\npub enum Native {\r\n    Print,\r\n}\r\n\r\nimpl Native {\r\n    pub fn call(\u0026self, args: Vector\u003cValue\u003e) -\u003e Value {\r\n        match self {\r\n            Native::Print =\u003e print(args),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg_attr(tarpaulin, skip)]\r\nfn print(args: Vector\u003cValue\u003e) -\u003e Value {\r\n    let string = args\r\n        .iter()\r\n        .map(|v| v.to_string())\r\n        .collect::\u003cVec\u003cString\u003e\u003e()\r\n        .join(\" \");\r\n    println!(\"{}\", string);\r\n    Value::Nothing\r\n}\r\n\r\npub fn global() -\u003e Scope {\r\n    hashmap! {\r\n        \"print\".to_string() =\u003e Value::NativeFunction(Native::Print)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn global_test() {\r\n        let global = global();\r\n        assert_eq!(\r\n            *global.get(\"print\").unwrap(),\r\n            Value::NativeFunction(Native::Print)\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":11,"address":4724912,"length":1,"stats":{"Line":0}},{"line":12,"address":null,"length":0,"stats":{"Line":0}},{"line":13,"address":4724921,"length":1,"stats":{"Line":0}},{"line":29,"address":4725456,"length":1,"stats":{"Line":1}},{"line":30,"address":4725463,"length":1,"stats":{"Line":1}},{"line":31,"address":4725500,"length":1,"stats":{"Line":1}},{"line":40,"address":4768960,"length":1,"stats":{"Line":2}},{"line":41,"address":4768967,"length":1,"stats":{"Line":1}},{"line":42,"address":4769057,"length":1,"stats":{"Line":1}},{"line":43,"address":4768994,"length":1,"stats":{"Line":1}}],"covered":7,"coverable":10},{"path":["/","volume","src","error.rs"],"content":"use std::fmt;\r\nuse std::sync::Arc;\r\n\r\n#[derive(Debug)]\r\npub struct OmgError {\r\n    pub msg: String,\r\n    pub pos: String,\r\n}\r\n\r\nimpl OmgError {\r\n    pub fn new\u003cS\u003e(msg: S, pos: Position) -\u003e Self\r\n    where\r\n        S: Into\u003cString\u003e,\r\n    {\r\n        OmgError {\r\n            msg: msg.into(),\r\n            pos: pos.to_string(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for OmgError {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        writeln!(f, \"{}: {}\", self.pos, self.msg)\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct Position {\r\n    pub src: Arc\u003cString\u003e,\r\n    pub line: u64,\r\n    pub column: u64,\r\n}\r\n\r\nimpl Position {\r\n    pub fn new\u003cS\u003e(src: S) -\u003e Self\r\n    where\r\n        S: Into\u003cString\u003e,\r\n    {\r\n        Position {\r\n            src: Arc::new(src.into()),\r\n            line: 1,\r\n            column: 1,\r\n        }\r\n    }\r\n\r\n    pub fn with_pos(\u0026self, line: u64, column: u64) -\u003e Self {\r\n        Position {\r\n            src: Arc::clone(\u0026self.src),\r\n            line,\r\n            column,\r\n        }\r\n    }\r\n\r\n    pub fn add(\u0026self, count: u64) -\u003e Self {\r\n        Position {\r\n            src: Arc::clone(\u0026self.src),\r\n            line: self.line,\r\n            column: self.column + count,\r\n        }\r\n    }\r\n\r\n    pub fn newline(\u0026self) -\u003e Self {\r\n        Position {\r\n            src: Arc::clone(\u0026self.src),\r\n            line: self.line + 1,\r\n            column: 1,\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Position {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}:{}:{}\", self.src, self.line, self.column)\r\n    }\r\n}\r\n\r\npub type Result\u003cT\u003e = std::result::Result\u003cT, OmgError\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn position() {\r\n        let pos = Position::new(\"test.omg\").with_pos(1, 2);\r\n        let display = format!(\"{}\", pos);\r\n        assert_eq!(display, \"test.omg:1:2\");\r\n    }\r\n\r\n    #[test]\r\n    fn omg_error() {\r\n        let pos = Position::new(\"test.omg\").with_pos(1, 2);\r\n        let error = OmgError::new(\"Test error\".to_owned(), pos);\r\n        let display = format!(\"{}\", error);\r\n        assert_eq!(display, \"test.omg:1:2: Test error\\n\");\r\n    }\r\n}\r\n","traces":[{"line":11,"address":4846160,"length":1,"stats":{"Line":1}},{"line":16,"address":4846167,"length":1,"stats":{"Line":1}},{"line":17,"address":4846262,"length":1,"stats":{"Line":1}},{"line":23,"address":4916064,"length":1,"stats":{"Line":1}},{"line":24,"address":4916081,"length":1,"stats":{"Line":1}},{"line":36,"address":4846384,"length":1,"stats":{"Line":1}},{"line":41,"address":4846401,"length":1,"stats":{"Line":1}},{"line":47,"address":4916352,"length":1,"stats":{"Line":1}},{"line":49,"address":4916374,"length":1,"stats":{"Line":1}},{"line":55,"address":4916448,"length":1,"stats":{"Line":1}},{"line":57,"address":4916465,"length":1,"stats":{"Line":1}},{"line":58,"address":4916507,"length":1,"stats":{"Line":1}},{"line":59,"address":4916516,"length":1,"stats":{"Line":1}},{"line":63,"address":4916640,"length":1,"stats":{"Line":1}},{"line":65,"address":4916652,"length":1,"stats":{"Line":1}},{"line":66,"address":4916694,"length":1,"stats":{"Line":1}},{"line":73,"address":4916816,"length":1,"stats":{"Line":1}},{"line":74,"address":4916833,"length":1,"stats":{"Line":1}},{"line":85,"address":4921104,"length":1,"stats":{"Line":2}},{"line":86,"address":4921118,"length":1,"stats":{"Line":1}},{"line":87,"address":4921221,"length":1,"stats":{"Line":1}},{"line":88,"address":4921383,"length":1,"stats":{"Line":1}},{"line":92,"address":4921904,"length":1,"stats":{"Line":2}},{"line":93,"address":4921918,"length":1,"stats":{"Line":1}},{"line":94,"address":4922020,"length":1,"stats":{"Line":1}},{"line":95,"address":4922120,"length":1,"stats":{"Line":1}},{"line":96,"address":4922300,"length":1,"stats":{"Line":1}}],"covered":27,"coverable":27},{"path":["/","volume","src","lib.rs"],"content":"#![warn(clippy::all)]\r\nmod core_lib;\r\nmod error;\r\nmod parser;\r\nmod runtime;\r\nmod tokens;\r\nmod value;\r\n\r\nuse core_lib::global;\r\nuse error::{Position, Result};\r\nuse parser::parse_block;\r\nuse runtime::Runtime;\r\nuse tokens::Tokens;\r\nuse value::Scope;\r\n\r\nuse std::fs;\r\n\r\npub use error::OmgError;\r\n\r\n#[macro_use]\r\nextern crate im;\r\n\r\npub struct OmgLang {\r\n    global: Scope,\r\n}\r\n\r\nimpl OmgLang {\r\n    pub fn new() -\u003e Self {\r\n        OmgLang { global: global() }\r\n    }\r\n\r\n    #[cfg_attr(tarpaulin, skip)]\r\n    pub fn run_file(\u0026self, file: \u0026str) -\u003e Result\u003c()\u003e {\r\n        let source = OmgLang::load_file(\u0026file)?;\r\n        let mut tokens = Tokens::lex(\u0026source, file)?;\r\n        let exp = parse_block(\u0026mut tokens)?;\r\n        let mut runtime = Runtime::new(\u0026self.global);\r\n        runtime.run(\u0026exp)?;\r\n        Ok(())\r\n    }\r\n\r\n    #[cfg_attr(tarpaulin, skip)]\r\n    fn load_file(file: \u0026str) -\u003e Result\u003cString\u003e {\r\n        match fs::read_to_string(file) {\r\n            Ok(s) =\u003e Ok(s),\r\n            Err(err) =\u003e Err(OmgError::new(err.to_string(), Position::new(file))),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn global_test() {\r\n        let omg = OmgLang::new();\r\n        assert_eq!(omg.global, global());\r\n    }\r\n}\r\n","traces":[{"line":28,"address":4825296,"length":1,"stats":{"Line":1}},{"line":29,"address":4825303,"length":1,"stats":{"Line":1}},{"line":56,"address":4281296,"length":1,"stats":{"Line":2}},{"line":57,"address":4902375,"length":1,"stats":{"Line":1}},{"line":58,"address":4902417,"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","volume","src","parser.rs"],"content":"use crate::{\r\n    error::{OmgError, Position, Result},\r\n    tokens::{TokenType, Tokens},\r\n    value::Value,\r\n};\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Block {\r\n    pub statements: Vec\u003cExp\u003e,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Call {\r\n    pub name: String,\r\n    pub args: Vec\u003cExp\u003e,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Literal {\r\n    pub value: Value,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Assignment {\r\n    pub name: String,\r\n    pub value: Box\u003cExp\u003e,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Variable {\r\n    pub name: String,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct OpAdd {\r\n    pub lhs: Box\u003cExp\u003e,\r\n    pub rhs: Box\u003cExp\u003e,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum Exp {\r\n    Block(Block),\r\n    Call(Call),\r\n    Literal(Literal),\r\n    Assignment(Assignment),\r\n    Variable(Variable),\r\n    OpAdd(OpAdd),\r\n}\r\n\r\nimpl Exp {\r\n    pub fn new_block(statements: Vec\u003cExp\u003e, pos: Position) -\u003e Exp {\r\n        Exp::Block(Block { statements, pos })\r\n    }\r\n\r\n    pub fn new_call(name: String, args: Vec\u003cExp\u003e, pos: Position) -\u003e Exp {\r\n        Exp::Call(Call { name, args, pos })\r\n    }\r\n\r\n    pub fn new_literal(value: Value, pos: Position) -\u003e Exp {\r\n        Exp::Literal(Literal { value, pos })\r\n    }\r\n\r\n    pub fn new_assignment(name: String, value: Box\u003cExp\u003e, pos: Position) -\u003e Exp {\r\n        Exp::Assignment(Assignment { name, value, pos })\r\n    }\r\n\r\n    pub fn new_variable(name: String, pos: Position) -\u003e Exp {\r\n        Exp::Variable(Variable { name, pos })\r\n    }\r\n\r\n    pub fn new_op_add(lhs: Box\u003cExp\u003e, rhs: Box\u003cExp\u003e, pos: Position) -\u003e Exp {\r\n        Exp::OpAdd(OpAdd { lhs, rhs, pos })\r\n    }\r\n\r\n    fn position(\u0026self) -\u003e Position {\r\n        match self {\r\n            Exp::Block(b) =\u003e b.pos.clone(),\r\n            Exp::Call(c) =\u003e c.pos.clone(),\r\n            Exp::Literal(l) =\u003e l.pos.clone(),\r\n            Exp::Assignment(a) =\u003e a.pos.clone(),\r\n            Exp::Variable(v) =\u003e v.pos.clone(),\r\n            Exp::OpAdd(a) =\u003e a.pos.clone(),\r\n        }\r\n    }\r\n}\r\n\r\npub fn parse_block(tokens: \u0026mut Tokens) -\u003e Result\u003cExp\u003e {\r\n    let mut statements = Vec::new();\r\n    let pos = tokens.position();\r\n    loop {\r\n        let exp = parse(tokens)?;\r\n        tokens.next();\r\n        let t = tokens.current();\r\n        if t.token_type == TokenType::Semicolon {\r\n            statements.push(exp);\r\n            tokens.next();\r\n        } else if t.token_type != TokenType::End {\r\n            return Err(OmgError::new(\r\n                format!(\"Expected ; found {}\", t.slice),\r\n                tokens.position(),\r\n            ));\r\n        }\r\n        if tokens.current().token_type == TokenType::End {\r\n            break;\r\n        }\r\n    }\r\n    Ok(Exp::new_block(statements, pos))\r\n}\r\n\r\npub fn parse(tokens: \u0026mut Tokens) -\u003e Result\u003cExp\u003e {\r\n    // parse left hand side;\r\n    let lhs = match tokens.current().token_type {\r\n        TokenType::Identifier =\u003e parse_identifier(tokens),\r\n        TokenType::Number =\u003e match tokens.current().slice.parse() {\r\n            Ok(i) =\u003e Ok(Exp::new_literal(Value::Number(i), tokens.position())),\r\n            Err(err) =\u003e Err(OmgError::new(\r\n                format!(\r\n                    \"Unable to covert {} into an integer: {}\",\r\n                    tokens.current().slice,\r\n                    err\r\n                ),\r\n                tokens.position(),\r\n            )),\r\n        },\r\n        TokenType::True =\u003e Ok(Exp::new_literal(Value::True, tokens.position())),\r\n        TokenType::False =\u003e Ok(Exp::new_literal(Value::False, tokens.position())),\r\n        _ =\u003e Err(OmgError::new(\r\n            format!(\r\n                \"Expected identifier or number found {}\",\r\n                tokens.current().slice\r\n            ),\r\n            tokens.position(),\r\n        )),\r\n    }?;\r\n\r\n    match tokens.peek().token_type {\r\n        TokenType::OpAdd =\u003e {\r\n            tokens.next(); // at OpAdd\r\n            tokens.next(); // at next expression\r\n            let rhs = parse(tokens)?;\r\n            let pos = lhs.position();\r\n            Ok(Exp::new_op_add(Box::new(lhs), Box::new(rhs), pos))\r\n        }\r\n        _ =\u003e Ok(lhs),\r\n    }\r\n}\r\n\r\nfn parse_identifier(tokens: \u0026mut Tokens) -\u003e Result\u003cExp\u003e {\r\n    match tokens.peek().token_type {\r\n        TokenType::ParenthesesOpen =\u003e parse_call(tokens),\r\n        TokenType::Assignment =\u003e {\r\n            let name = tokens.slice().to_string();\r\n            let pos = tokens.position();\r\n            tokens.next(); // at assignment\r\n            tokens.next(); // at next expression\r\n            let exp = parse(tokens)?;\r\n            Ok(Exp::new_assignment(name, Box::new(exp), pos))\r\n        }\r\n        _ =\u003e Ok(Exp::new_variable(\r\n            tokens.slice().to_string(),\r\n            tokens.position(),\r\n        )),\r\n    }\r\n}\r\n\r\nfn parse_call(tokens: \u0026mut Tokens) -\u003e Result\u003cExp\u003e {\r\n    let token = tokens.current();\r\n    let pos = tokens.position();\r\n    let name = token.slice.to_string();\r\n    tokens.next(); // ParenthesesOpen\r\n    let mut args = Vec::new();\r\n    if !tokens.expect(TokenType::ParenthesesClose) {\r\n        loop {\r\n            tokens.next();\r\n            args.push(parse(tokens)?);\r\n            tokens.next();\r\n            match tokens.current().token_type {\r\n                TokenType::ParenthesesClose =\u003e break,\r\n                TokenType::Comma =\u003e (),\r\n                _ =\u003e {\r\n                    return Err(OmgError::new(\r\n                        format!(\"Expected ) or , found {}\", tokens.current().slice),\r\n                        tokens.position(),\r\n                    ))\r\n                }\r\n            };\r\n        }\r\n    }\r\n    Ok(Exp::new_call(name, args, pos))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[cfg_attr(tarpaulin, skip)]\r\n    impl Exp {\r\n        fn block(\u0026self) -\u003e Result\u003c\u0026Block\u003e {\r\n            if let Exp::Block(exp) = self {\r\n                Ok(\u0026exp)\r\n            } else {\r\n                Err(self.type_error(\"Block\"))\r\n            }\r\n        }\r\n\r\n        fn call(\u0026self) -\u003e Result\u003c\u0026Call\u003e {\r\n            if let Exp::Call(exp) = self {\r\n                Ok(\u0026exp)\r\n            } else {\r\n                Err(self.type_error(\"Call\"))\r\n            }\r\n        }\r\n\r\n        fn literal(\u0026self) -\u003e Result\u003c\u0026Literal\u003e {\r\n            if let Exp::Literal(exp) = self {\r\n                Ok(\u0026exp)\r\n            } else {\r\n                Err(self.type_error(\"Literal\"))\r\n            }\r\n        }\r\n\r\n        fn assignment(\u0026self) -\u003e Result\u003c\u0026Assignment\u003e {\r\n            if let Exp::Assignment(exp) = self {\r\n                Ok(\u0026exp)\r\n            } else {\r\n                Err(self.type_error(\"Assignment\"))\r\n            }\r\n        }\r\n\r\n        fn variable(\u0026self) -\u003e Result\u003c\u0026Variable\u003e {\r\n            if let Exp::Variable(exp) = self {\r\n                Ok(\u0026exp)\r\n            } else {\r\n                Err(self.type_error(\"Variable\"))\r\n            }\r\n        }\r\n\r\n        fn name(\u0026self) -\u003e \u0026'static str {\r\n            match self {\r\n                Exp::Block(_) =\u003e \"Block\",\r\n                Exp::Call(_) =\u003e \"Call\",\r\n                Exp::Literal(_) =\u003e \"Literal\",\r\n                Exp::Assignment(_) =\u003e \"Assignment\",\r\n                Exp::Variable(_) =\u003e \"Variable\",\r\n                Exp::OpAdd(_) =\u003e \"OpAdd\",\r\n            }\r\n        }\r\n\r\n        fn type_error(\u0026self, expected: \u0026str) -\u003e OmgError {\r\n            OmgError::new(\r\n                format!(\"Expected {} found {}\", expected, self.name()),\r\n                self.position(),\r\n            )\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn number() {\r\n        let mut tokens = Tokens::new_test(\"42\");\r\n        let exp = parse(\u0026mut tokens).unwrap();\r\n        let literal = exp.literal().unwrap();\r\n        assert_eq!(literal.value, Value::Number(42.0));\r\n    }\r\n\r\n    #[test]\r\n    fn call() {\r\n        let mut tokens = Tokens::new_test(\"print(42)\");\r\n        let exp = parse(\u0026mut tokens).unwrap();\r\n        let call = exp.call().unwrap();\r\n        assert_eq!(call.name, \"print\".to_string());\r\n        let arg = call.args[0].literal().unwrap();\r\n        assert_eq!(arg.value, Value::Number(42.0));\r\n    }\r\n\r\n    #[test]\r\n    fn call_two_args() {\r\n        let mut tokens = Tokens::new_test(\"print(1,2)\");\r\n        let exp = parse(\u0026mut tokens).unwrap();\r\n        let call = exp.call().unwrap();\r\n        assert_eq!(call.name, \"print\".to_string());\r\n        let arg = call.args[0].literal().unwrap();\r\n        assert_eq!(arg.value, Value::Number(1.0));\r\n        let arg = call.args[1].literal().unwrap();\r\n        assert_eq!(arg.value, Value::Number(2.0));\r\n    }\r\n\r\n    #[test]\r\n    fn call_no_end() {\r\n        let mut tokens = Tokens::new_test(\"print(42\");\r\n        parse(\u0026mut tokens).unwrap_err();\r\n    }\r\n\r\n    #[test]\r\n    fn block() {\r\n        let mut tokens = Tokens::new_test(\"42;\");\r\n        let exp = parse_block(\u0026mut tokens).unwrap();\r\n        let block = exp.block().unwrap();\r\n        let statement = block.statements[0].literal().unwrap();\r\n        assert_eq!(statement.value, Value::Number(42.0));\r\n    }\r\n\r\n    #[test]\r\n    fn block_error() {\r\n        let mut tokens = Tokens::new_test(\"42(\");\r\n        parse_block(\u0026mut tokens).unwrap_err();\r\n    }\r\n\r\n    #[test]\r\n    fn assignment() {\r\n        let mut tokens = Tokens::new_test(\"test = 42\");\r\n        let exp = parse(\u0026mut tokens).unwrap();\r\n        let assignment = exp.assignment().unwrap();\r\n        assert_eq!(assignment.name, \"test\");\r\n        let value = assignment.value.literal().unwrap();\r\n        assert_eq!(value.value, Value::Number(42.0));\r\n    }\r\n\r\n    #[test]\r\n    fn variable() {\r\n        let mut tokens = Tokens::new_test(\"test\");\r\n        let exp = parse(\u0026mut tokens).unwrap();\r\n        let variable = exp.variable().unwrap();\r\n        assert_eq!(variable.name, \"test\");\r\n    }\r\n\r\n    #[test]\r\n    fn in_valid() {\r\n        let mut tokens = Tokens::new_test(\",\");\r\n        parse(\u0026mut tokens).unwrap_err();\r\n    }\r\n}\r\n","traces":[{"line":57,"address":4281328,"length":1,"stats":{"Line":1}},{"line":58,"address":4281335,"length":1,"stats":{"Line":1}},{"line":61,"address":4281520,"length":1,"stats":{"Line":1}},{"line":62,"address":4281530,"length":1,"stats":{"Line":1}},{"line":65,"address":4281792,"length":1,"stats":{"Line":1}},{"line":66,"address":4281810,"length":1,"stats":{"Line":1}},{"line":69,"address":4281952,"length":1,"stats":{"Line":1}},{"line":70,"address":4281967,"length":1,"stats":{"Line":1}},{"line":73,"address":4282160,"length":1,"stats":{"Line":1}},{"line":74,"address":4282167,"length":1,"stats":{"Line":1}},{"line":77,"address":4282352,"length":1,"stats":{"Line":0}},{"line":78,"address":4282369,"length":1,"stats":{"Line":0}},{"line":81,"address":4282512,"length":1,"stats":{"Line":0}},{"line":82,"address":4282619,"length":1,"stats":{"Line":0}},{"line":83,"address":4282524,"length":1,"stats":{"Line":0}},{"line":84,"address":4282624,"length":1,"stats":{"Line":0}},{"line":85,"address":4282665,"length":1,"stats":{"Line":0}},{"line":86,"address":4282703,"length":1,"stats":{"Line":0}},{"line":87,"address":4282741,"length":1,"stats":{"Line":0}},{"line":88,"address":4282779,"length":1,"stats":{"Line":0}},{"line":93,"address":4282832,"length":1,"stats":{"Line":1}},{"line":94,"address":4282847,"length":1,"stats":{"Line":1}},{"line":95,"address":4282927,"length":1,"stats":{"Line":1}},{"line":96,"address":4284201,"length":1,"stats":{"Line":0}},{"line":97,"address":4282955,"length":1,"stats":{"Line":1}},{"line":98,"address":4284395,"length":1,"stats":{"Line":1}},{"line":99,"address":4283421,"length":1,"stats":{"Line":1}},{"line":100,"address":4283451,"length":1,"stats":{"Line":1}},{"line":101,"address":4283494,"length":1,"stats":{"Line":1}},{"line":102,"address":4283635,"length":1,"stats":{"Line":1}},{"line":103,"address":4283602,"length":1,"stats":{"Line":1}},{"line":104,"address":4283857,"length":1,"stats":{"Line":1}},{"line":105,"address":4283662,"length":1,"stats":{"Line":1}},{"line":106,"address":4283837,"length":1,"stats":{"Line":1}},{"line":109,"address":4283988,"length":1,"stats":{"Line":1}},{"line":113,"address":4284085,"length":1,"stats":{"Line":1}},{"line":116,"address":4284656,"length":1,"stats":{"Line":1}},{"line":118,"address":4284674,"length":1,"stats":{"Line":1}},{"line":119,"address":4284787,"length":1,"stats":{"Line":1}},{"line":120,"address":4284876,"length":1,"stats":{"Line":1}},{"line":121,"address":4284925,"length":1,"stats":{"Line":1}},{"line":122,"address":4285142,"length":1,"stats":{"Line":0}},{"line":123,"address":4285187,"length":1,"stats":{"Line":0}},{"line":125,"address":4285158,"length":1,"stats":{"Line":0}},{"line":128,"address":4285454,"length":1,"stats":{"Line":0}},{"line":131,"address":4285577,"length":1,"stats":{"Line":0}},{"line":132,"address":4285701,"length":1,"stats":{"Line":0}},{"line":133,"address":4286051,"length":1,"stats":{"Line":1}},{"line":134,"address":4285854,"length":1,"stats":{"Line":1}},{"line":136,"address":4285825,"length":1,"stats":{"Line":1}},{"line":138,"address":4286028,"length":1,"stats":{"Line":1}},{"line":142,"address":4286546,"length":1,"stats":{"Line":1}},{"line":143,"address":4286554,"length":1,"stats":{"Line":1}},{"line":144,"address":4286578,"length":1,"stats":{"Line":0}},{"line":145,"address":4286593,"length":1,"stats":{"Line":0}},{"line":146,"address":4286608,"length":1,"stats":{"Line":0}},{"line":147,"address":4287023,"length":1,"stats":{"Line":0}},{"line":148,"address":4287031,"length":1,"stats":{"Line":0}},{"line":150,"address":4287526,"length":1,"stats":{"Line":1}},{"line":154,"address":4288240,"length":1,"stats":{"Line":1}},{"line":155,"address":4288258,"length":1,"stats":{"Line":1}},{"line":156,"address":4288354,"length":1,"stats":{"Line":1}},{"line":158,"address":4288428,"length":1,"stats":{"Line":1}},{"line":159,"address":4288482,"length":1,"stats":{"Line":1}},{"line":160,"address":4288513,"length":1,"stats":{"Line":1}},{"line":161,"address":4288528,"length":1,"stats":{"Line":1}},{"line":162,"address":4288543,"length":1,"stats":{"Line":1}},{"line":163,"address":4289000,"length":1,"stats":{"Line":1}},{"line":165,"address":4289260,"length":1,"stats":{"Line":1}},{"line":166,"address":4289183,"length":1,"stats":{"Line":1}},{"line":167,"address":4289237,"length":1,"stats":{"Line":1}},{"line":172,"address":4289968,"length":1,"stats":{"Line":1}},{"line":173,"address":4289983,"length":1,"stats":{"Line":1}},{"line":174,"address":4290076,"length":1,"stats":{"Line":1}},{"line":175,"address":4290102,"length":1,"stats":{"Line":1}},{"line":176,"address":4290137,"length":1,"stats":{"Line":1}},{"line":177,"address":4290157,"length":1,"stats":{"Line":1}},{"line":178,"address":4290164,"length":1,"stats":{"Line":1}},{"line":179,"address":4290910,"length":1,"stats":{"Line":1}},{"line":180,"address":4290219,"length":1,"stats":{"Line":1}},{"line":181,"address":4290231,"length":1,"stats":{"Line":1}},{"line":182,"address":4291700,"length":1,"stats":{"Line":1}},{"line":183,"address":4290838,"length":1,"stats":{"Line":1}},{"line":184,"address":4290860,"length":1,"stats":{"Line":1}},{"line":187,"address":4291119,"length":1,"stats":{"Line":1}},{"line":188,"address":4290915,"length":1,"stats":{"Line":1}},{"line":189,"address":4291099,"length":1,"stats":{"Line":1}},{"line":195,"address":4291216,"length":1,"stats":{"Line":1}},{"line":264,"address":4332912,"length":1,"stats":{"Line":2}},{"line":265,"address":4890782,"length":1,"stats":{"Line":1}},{"line":266,"address":4890830,"length":1,"stats":{"Line":1}},{"line":267,"address":4890882,"length":1,"stats":{"Line":1}},{"line":268,"address":4890934,"length":1,"stats":{"Line":1}},{"line":272,"address":4332944,"length":1,"stats":{"Line":2}},{"line":273,"address":4891438,"length":1,"stats":{"Line":1}},{"line":274,"address":4891492,"length":1,"stats":{"Line":1}},{"line":275,"address":4891553,"length":1,"stats":{"Line":1}},{"line":276,"address":4891614,"length":1,"stats":{"Line":1}},{"line":277,"address":4892107,"length":1,"stats":{"Line":1}},{"line":278,"address":4892191,"length":1,"stats":{"Line":1}},{"line":282,"address":4332976,"length":1,"stats":{"Line":2}},{"line":283,"address":4892718,"length":1,"stats":{"Line":1}},{"line":284,"address":4892772,"length":1,"stats":{"Line":1}},{"line":285,"address":4892833,"length":1,"stats":{"Line":1}},{"line":286,"address":4892894,"length":1,"stats":{"Line":1}},{"line":287,"address":4893423,"length":1,"stats":{"Line":1}},{"line":288,"address":4893519,"length":1,"stats":{"Line":1}},{"line":289,"address":4893752,"length":1,"stats":{"Line":1}},{"line":290,"address":4894014,"length":1,"stats":{"Line":1}},{"line":294,"address":4333008,"length":1,"stats":{"Line":2}},{"line":295,"address":4894542,"length":1,"stats":{"Line":1}},{"line":296,"address":4894583,"length":1,"stats":{"Line":1}},{"line":300,"address":4333040,"length":1,"stats":{"Line":2}},{"line":301,"address":4894686,"length":1,"stats":{"Line":1}},{"line":302,"address":4894734,"length":1,"stats":{"Line":1}},{"line":303,"address":4894786,"length":1,"stats":{"Line":1}},{"line":304,"address":4894838,"length":1,"stats":{"Line":1}},{"line":305,"address":4894915,"length":1,"stats":{"Line":1}},{"line":309,"address":4333072,"length":1,"stats":{"Line":2}},{"line":310,"address":4895422,"length":1,"stats":{"Line":1}},{"line":311,"address":4895463,"length":1,"stats":{"Line":1}},{"line":315,"address":4333104,"length":1,"stats":{"Line":2}},{"line":316,"address":4895566,"length":1,"stats":{"Line":1}},{"line":317,"address":4895620,"length":1,"stats":{"Line":1}},{"line":318,"address":4895681,"length":1,"stats":{"Line":1}},{"line":319,"address":4895736,"length":1,"stats":{"Line":1}},{"line":320,"address":4895969,"length":1,"stats":{"Line":1}},{"line":321,"address":4896206,"length":1,"stats":{"Line":1}},{"line":325,"address":4333136,"length":1,"stats":{"Line":2}},{"line":326,"address":4896718,"length":1,"stats":{"Line":1}},{"line":327,"address":4896766,"length":1,"stats":{"Line":1}},{"line":328,"address":4896818,"length":1,"stats":{"Line":1}},{"line":329,"address":4896870,"length":1,"stats":{"Line":1}},{"line":333,"address":4333168,"length":1,"stats":{"Line":2}},{"line":334,"address":4897374,"length":1,"stats":{"Line":1}},{"line":335,"address":4897415,"length":1,"stats":{"Line":1}}],"covered":114,"coverable":136},{"path":["/","volume","src","runtime.rs"],"content":"use im::Vector;\r\n\r\nuse super::{\r\n    error::{OmgError, Result},\r\n    parser::Exp,\r\n    value::{Scope, Value},\r\n};\r\n\r\npub struct Runtime {\r\n    local: Scope,\r\n}\r\n\r\nimpl Runtime {\r\n    pub fn new(global: \u0026Scope) -\u003e Runtime {\r\n        Runtime {\r\n            local: global.clone(),\r\n        }\r\n    }\r\n\r\n    pub fn run(\u0026mut self, exp: \u0026Exp) -\u003e Result\u003cValue\u003e {\r\n        self.run_exp(exp)\r\n    }\r\n\r\n    fn run_exp(\u0026mut self, exp: \u0026Exp) -\u003e Result\u003cValue\u003e {\r\n        match exp {\r\n            Exp::Call(call) =\u003e {\r\n                let v = self\r\n                    .local\r\n                    .get(\u0026call.name)\r\n                    .unwrap_or(\u0026Value::Nothing)\r\n                    .clone();\r\n                match v {\r\n                    Value::NativeFunction(native) =\u003e Ok(native.call(self.run_list(\u0026call.args)?)),\r\n                    _ =\u003e Err(OmgError::new(\r\n                        format!(\"Cant find function named {} to call\", call.name),\r\n                        call.pos.clone(),\r\n                    )),\r\n                }\r\n            }\r\n            Exp::Block(block) =\u003e {\r\n                self.run_list(\u0026block.statements)?;\r\n                Ok(Value::Nothing)\r\n            }\r\n            Exp::Literal(literal) =\u003e Ok(literal.value.clone()),\r\n            Exp::Assignment(assignment) =\u003e {\r\n                let value = self.run_exp(\u0026assignment.value)?;\r\n                self.local.insert(assignment.name.clone(), value);\r\n                Ok(Value::Nothing)\r\n            }\r\n            Exp::Variable(variable) =\u003e Ok(self\r\n                .local\r\n                .get(\u0026variable.name)\r\n                .unwrap_or(\u0026Value::Nothing)\r\n                .clone()),\r\n            Exp::OpAdd(add) =\u003e Ok(self.run(\u0026add.lhs)?.add(\u0026self.run(\u0026add.rhs)?)),\r\n        }\r\n    }\r\n\r\n    fn run_list(\u0026mut self, expressions: \u0026[Exp]) -\u003e Result\u003cVector\u003cValue\u003e\u003e {\r\n        expressions.iter().map(|exp| self.run_exp(exp)).collect()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::error::Position;\r\n\r\n    #[test]\r\n    fn literal() {\r\n        let mut run = Runtime::new(\u0026Scope::new());\r\n\r\n        let value = Value::Number(42.0);\r\n        let exp = Exp::new_literal(value.clone(), Position::new(\"test\"));\r\n        assert_eq!(run.run(\u0026exp).unwrap(), value);\r\n    }\r\n\r\n    #[test]\r\n    fn block() {\r\n        let mut run = Runtime::new(\u0026Scope::new());\r\n\r\n        let exp = Exp::new_block(\r\n            vec![Exp::new_literal(Value::Number(42.0), Position::new(\"test\"))],\r\n            Position::new(\"test\"),\r\n        );\r\n        assert_eq!(run.run(\u0026exp).unwrap(), Value::Nothing);\r\n    }\r\n\r\n    #[test]\r\n    fn call_not_found() {\r\n        let mut run = Runtime::new(\u0026Scope::new());\r\n\r\n        let exp = Exp::new_call(\"test\".to_string(), Vec::new(), Position::new(\"test\"));\r\n        run.run(\u0026exp).unwrap_err();\r\n    }\r\n\r\n    #[test]\r\n    fn set_get_variable() {\r\n        let mut run = Runtime::new(\u0026Scope::new());\r\n        let set = Exp::new_assignment(\r\n            \"test\".to_string(),\r\n            Box::new(Exp::new_literal(Value::Number(42.0), Position::new(\"test\"))),\r\n            Position::new(\"test\"),\r\n        );\r\n        run.run(\u0026set).unwrap();\r\n        let get = Exp::new_variable(\"test\".to_string(), Position::new(\"test\"));\r\n        assert_eq!(run.run(\u0026get).unwrap(), Value::Number(42.0));\r\n    }\r\n}\r\n","traces":[{"line":14,"address":4897712,"length":1,"stats":{"Line":1}},{"line":16,"address":4897724,"length":1,"stats":{"Line":1}},{"line":20,"address":4897808,"length":1,"stats":{"Line":1}},{"line":21,"address":4897825,"length":1,"stats":{"Line":1}},{"line":24,"address":4897856,"length":1,"stats":{"Line":1}},{"line":25,"address":4899101,"length":1,"stats":{"Line":1}},{"line":26,"address":4897882,"length":1,"stats":{"Line":1}},{"line":27,"address":4898051,"length":1,"stats":{"Line":1}},{"line":28,"address":null,"length":0,"stats":{"Line":0}},{"line":29,"address":4898059,"length":1,"stats":{"Line":1}},{"line":30,"address":null,"length":0,"stats":{"Line":0}},{"line":31,"address":null,"length":0,"stats":{"Line":0}},{"line":32,"address":4901485,"length":1,"stats":{"Line":0}},{"line":33,"address":4898147,"length":1,"stats":{"Line":1}},{"line":34,"address":4899003,"length":1,"stats":{"Line":1}},{"line":35,"address":4898785,"length":1,"stats":{"Line":1}},{"line":36,"address":4898973,"length":1,"stats":{"Line":1}},{"line":40,"address":4899106,"length":1,"stats":{"Line":1}},{"line":41,"address":4899126,"length":1,"stats":{"Line":1}},{"line":42,"address":4901722,"length":1,"stats":{"Line":1}},{"line":44,"address":4899663,"length":1,"stats":{"Line":1}},{"line":45,"address":4899756,"length":1,"stats":{"Line":1}},{"line":46,"address":4899776,"length":1,"stats":{"Line":1}},{"line":47,"address":4900141,"length":1,"stats":{"Line":1}},{"line":48,"address":4900225,"length":1,"stats":{"Line":1}},{"line":50,"address":4900283,"length":1,"stats":{"Line":1}},{"line":51,"address":null,"length":0,"stats":{"Line":0}},{"line":52,"address":4900311,"length":1,"stats":{"Line":1}},{"line":53,"address":null,"length":0,"stats":{"Line":0}},{"line":54,"address":null,"length":0,"stats":{"Line":0}},{"line":55,"address":4900421,"length":1,"stats":{"Line":0}},{"line":59,"address":4902192,"length":1,"stats":{"Line":1}},{"line":60,"address":4902214,"length":1,"stats":{"Line":2}},{"line":70,"address":4772128,"length":1,"stats":{"Line":2}},{"line":71,"address":4820135,"length":1,"stats":{"Line":1}},{"line":73,"address":4820237,"length":1,"stats":{"Line":1}},{"line":74,"address":4820265,"length":1,"stats":{"Line":1}},{"line":75,"address":4820387,"length":1,"stats":{"Line":1}},{"line":79,"address":4772160,"length":1,"stats":{"Line":2}},{"line":80,"address":4820983,"length":1,"stats":{"Line":1}},{"line":82,"address":4821340,"length":1,"stats":{"Line":1}},{"line":83,"address":4821081,"length":1,"stats":{"Line":1}},{"line":84,"address":4821294,"length":1,"stats":{"Line":1}},{"line":86,"address":4821402,"length":1,"stats":{"Line":1}},{"line":90,"address":4772192,"length":1,"stats":{"Line":2}},{"line":91,"address":4822087,"length":1,"stats":{"Line":1}},{"line":93,"address":4822179,"length":1,"stats":{"Line":1}},{"line":94,"address":4822348,"length":1,"stats":{"Line":1}},{"line":98,"address":4772224,"length":1,"stats":{"Line":2}},{"line":99,"address":4822631,"length":1,"stats":{"Line":1}},{"line":100,"address":4823004,"length":1,"stats":{"Line":1}},{"line":101,"address":4822747,"length":1,"stats":{"Line":1}},{"line":102,"address":4822792,"length":1,"stats":{"Line":1}},{"line":103,"address":4822958,"length":1,"stats":{"Line":1}},{"line":105,"address":4823096,"length":1,"stats":{"Line":1}},{"line":106,"address":4823147,"length":1,"stats":{"Line":1}},{"line":107,"address":4823277,"length":1,"stats":{"Line":1}}],"covered":49,"coverable":57},{"path":["/","volume","src","tokens.rs"],"content":"use crate::error::{OmgError, Position, Result};\r\n\r\nuse logos::{Extras, Logos};\r\n\r\n#[derive(Default)]\r\npub struct TokenExtra {\r\n    line: u64,\r\n    column: u64,\r\n}\r\n\r\nimpl TokenExtra {\r\n    fn update_pos(\u0026mut self, pos: Position) -\u003e Position {\r\n        let mut pos = pos;\r\n        while self.line \u003e 0 {\r\n            pos = pos.newline();\r\n            self.line -= 1;\r\n        }\r\n        pos = pos.add(self.column);\r\n        self.column = 0;\r\n\r\n        return pos;\r\n    }\r\n}\r\n\r\nimpl Extras for TokenExtra {\r\n    fn on_advance(\u0026mut self) {}\r\n\r\n    fn on_whitespace(\u0026mut self, byte: u8) {\r\n        if byte == 10 {\r\n            self.line += 1;\r\n            self.column = 0\r\n        } else {\r\n            self.column += 1;\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Logos, Debug, Clone, Copy, PartialEq)]\r\n#[extras = \"TokenExtra\"]\r\npub enum TokenType {\r\n    #[end]\r\n    End,\r\n\r\n    #[error]\r\n    Error,\r\n\r\n    #[regex = \"[a-zA-Z_][a-zA-Z0-9_]*\"]\r\n    Identifier,\r\n\r\n    #[regex = \"\\\\d+\"]\r\n    Number,\r\n\r\n    #[token = \"true\"]\r\n    True,\r\n\r\n    #[token = \"false\"]\r\n    False,\r\n\r\n    #[token = \"(\"]\r\n    ParenthesesOpen,\r\n\r\n    #[token = \")\"]\r\n    ParenthesesClose,\r\n\r\n    #[token = \",\"]\r\n    Comma,\r\n\r\n    #[token = \";\"]\r\n    Semicolon,\r\n\r\n    #[token = \"=\"]\r\n    Assignment,\r\n\r\n    #[token = \"+\"]\r\n    OpAdd,\r\n\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Token\u003c'a\u003e {\r\n    pub token_type: TokenType,\r\n    pub slice: \u0026'a str,\r\n    pub pos: Position,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Tokens\u003c'a\u003e {\r\n    tokens: Vec\u003cToken\u003c'a\u003e\u003e,\r\n    index: usize,\r\n}\r\n\r\nimpl\u003c'a\u003e Tokens\u003c'a\u003e {\r\n    pub fn lex(code: \u0026'a str, file: \u0026'a str) -\u003e Result\u003cSelf\u003e {\r\n        let mut tokens = Vec::new();\r\n        let mut lexer = TokenType::lexer(code);\r\n        let mut pos = Position::new(file);\r\n        loop {\r\n            if lexer.token == TokenType::Error {\r\n                return Err(OmgError::new(\r\n                    format!(\"Found unknown character in \\\"{}\\\" in file.\", lexer.slice()),\r\n                    pos,\r\n                ));\r\n            }\r\n            tokens.push(Token {\r\n                token_type: lexer.token,\r\n                slice: lexer.slice(),\r\n                pos: pos.clone(),\r\n            });\r\n            if lexer.token == TokenType::End {\r\n                break;\r\n            }\r\n            pos = pos.add(lexer.slice().len() as u64);\r\n            lexer.advance();\r\n            pos = lexer.extras.update_pos(pos);\r\n        }\r\n\r\n        Ok(Tokens { tokens, index: 0 })\r\n    }\r\n\r\n    pub fn next(\u0026mut self) {\r\n        self.index += 1;\r\n        if self.index \u003e= self.tokens.len() {\r\n            self.index = self.tokens.len() - 1;\r\n        }\r\n    }\r\n\r\n    pub fn expect(\u0026mut self, token_type: TokenType) -\u003e bool {\r\n        if self.get(self.index + 1).token_type == token_type {\r\n            self.next();\r\n            return true;\r\n        }\r\n        false\r\n    }\r\n\r\n    pub fn current(\u0026self) -\u003e \u0026Token {\r\n        \u0026self.tokens[self.index]\r\n    }\r\n\r\n    pub fn peek(\u0026self) -\u003e \u0026Token {\r\n        self.get(self.index + 1)\r\n    }\r\n\r\n    pub fn position(\u0026self) -\u003e Position {\r\n        self.current().pos.clone()\r\n    }\r\n\r\n    pub fn slice(\u0026self) -\u003e \u0026str {\r\n        self.current().slice\r\n    }\r\n\r\n    fn get(\u0026self, index: usize) -\u003e \u0026Token {\r\n        if index \u003e= self.tokens.len() {\r\n            return \u0026self.tokens[self.tokens.len() - 1];\r\n        }\r\n        \u0026self.tokens[index]\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nimpl\u003c'a\u003e Tokens\u003c'a\u003e {\r\n    pub fn new_test(code: \u0026'a str) -\u003e Self {\r\n        Tokens::lex(code, \"test_code\").expect(\"Failed to tokenize test_data:\")\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn one_of_each() {\r\n        let mut tokens = Tokens::new_test(\"test 42 ( ) , ;\");\r\n        assert_eq!(tokens.current().token_type, TokenType::Identifier);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Number);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::ParenthesesOpen);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::ParenthesesClose);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Comma);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Semicolon);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn go_pass_end() {\r\n        let mut tokens = Tokens::new_test(\"42\");\r\n        tokens.next(); // At end.\r\n        tokens.next(); // over the end.\r\n        assert_eq!(tokens.current().token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn expect_true() {\r\n        let mut tokens = Tokens::new_test(\"test 42\");\r\n        assert_eq!(tokens.expect(TokenType::Number), true);\r\n        assert_eq!(tokens.current().token_type, TokenType::Number);\r\n    }\r\n\r\n    #[test]\r\n    fn expect_false() {\r\n        let mut tokens = Tokens::new_test(\"test 42\");\r\n        assert_eq!(tokens.expect(TokenType::Semicolon), false);\r\n        assert_eq!(tokens.current().token_type, TokenType::Identifier);\r\n    }\r\n\r\n    #[test]\r\n    fn get_pass_end() {\r\n        let tokens = Tokens::new_test(\"42\");\r\n        assert_eq!(tokens.get(2).token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn track_column() {\r\n        let mut tokens = Tokens::new_test(\"test 2 3 4\");\r\n        assert_eq!(tokens.current().pos.column, 1);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.column, 6);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.column, 8);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.column, 10);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.column, 11);\r\n    }\r\n\r\n    #[test]\r\n    fn track_line() {\r\n        let mut tokens = Tokens::new_test(\"test 2\\r\\n3 4\");\r\n        assert_eq!(tokens.current().pos.line, 1);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.line, 1);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.line, 2);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.line, 2);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().pos.line, 2);\r\n        assert_eq!(tokens.current().pos.column, 4);\r\n    }\r\n\r\n    #[test]\r\n    fn position() {\r\n        let mut tokens = Tokens::lex(\"test 2\\r\\n3 4\", \"test.omg\").unwrap();\r\n        tokens.next();\r\n        tokens.next();\r\n        tokens.next();\r\n        assert_eq!(tokens.position(), Position::new(\"test.omg\").with_pos(2, 3));\r\n    }\r\n\r\n    #[test]\r\n    fn slice() {\r\n        let tokens = Tokens::lex(\"test\", \"test.omg\").unwrap();\r\n        assert_eq!(tokens.slice(), \"test\");\r\n    }\r\n\r\n    #[test]\r\n    fn unknown_token() {\r\n        let result = Tokens::lex(\"test @\", \"test.omg\");\r\n        let err = result.expect_err(\"@ should not be valid omg code for this test\");\r\n\r\n        assert_eq!(err.msg, \"Found unknown character in \\\"@\\\" in file.\");\r\n    }\r\n}\r\n","traces":[{"line":12,"address":4830336,"length":1,"stats":{"Line":1}},{"line":13,"address":4830351,"length":1,"stats":{"Line":1}},{"line":14,"address":4830387,"length":1,"stats":{"Line":1}},{"line":15,"address":4830434,"length":1,"stats":{"Line":1}},{"line":16,"address":4830477,"length":1,"stats":{"Line":1}},{"line":18,"address":4830398,"length":1,"stats":{"Line":1}},{"line":19,"address":4830679,"length":1,"stats":{"Line":1}},{"line":21,"address":4830692,"length":1,"stats":{"Line":1}},{"line":26,"address":4830816,"length":1,"stats":{"Line":1}},{"line":28,"address":4830832,"length":1,"stats":{"Line":1}},{"line":29,"address":4830848,"length":1,"stats":{"Line":1}},{"line":30,"address":4830855,"length":1,"stats":{"Line":1}},{"line":31,"address":4830923,"length":1,"stats":{"Line":1}},{"line":32,"address":null,"length":0,"stats":{"Line":0}},{"line":33,"address":4830882,"length":1,"stats":{"Line":1}},{"line":93,"address":4831008,"length":1,"stats":{"Line":1}},{"line":94,"address":4831050,"length":1,"stats":{"Line":1}},{"line":95,"address":4831117,"length":1,"stats":{"Line":1}},{"line":96,"address":4831148,"length":1,"stats":{"Line":1}},{"line":97,"address":4831187,"length":1,"stats":{"Line":1}},{"line":98,"address":4831207,"length":1,"stats":{"Line":1}},{"line":99,"address":4831555,"length":1,"stats":{"Line":1}},{"line":100,"address":4831251,"length":1,"stats":{"Line":1}},{"line":101,"address":4831491,"length":1,"stats":{"Line":1}},{"line":104,"address":4831724,"length":1,"stats":{"Line":1}},{"line":105,"address":4831268,"length":1,"stats":{"Line":1}},{"line":106,"address":4831287,"length":1,"stats":{"Line":1}},{"line":107,"address":4831713,"length":1,"stats":{"Line":1}},{"line":109,"address":4831812,"length":1,"stats":{"Line":1}},{"line":110,"address":null,"length":0,"stats":{"Line":0}},{"line":112,"address":4832005,"length":1,"stats":{"Line":1}},{"line":113,"address":4832452,"length":1,"stats":{"Line":1}},{"line":114,"address":4832096,"length":1,"stats":{"Line":1}},{"line":117,"address":4831851,"length":1,"stats":{"Line":1}},{"line":120,"address":4832560,"length":1,"stats":{"Line":1}},{"line":121,"address":4832569,"length":1,"stats":{"Line":1}},{"line":122,"address":4832608,"length":1,"stats":{"Line":1}},{"line":123,"address":4832655,"length":1,"stats":{"Line":1}},{"line":127,"address":4832752,"length":1,"stats":{"Line":1}},{"line":128,"address":4832768,"length":1,"stats":{"Line":1}},{"line":129,"address":4832859,"length":1,"stats":{"Line":1}},{"line":130,"address":4832878,"length":1,"stats":{"Line":1}},{"line":132,"address":4832871,"length":1,"stats":{"Line":1}},{"line":135,"address":4832928,"length":1,"stats":{"Line":1}},{"line":136,"address":4832937,"length":1,"stats":{"Line":1}},{"line":139,"address":4832976,"length":1,"stats":{"Line":1}},{"line":140,"address":4832985,"length":1,"stats":{"Line":1}},{"line":143,"address":4833072,"length":1,"stats":{"Line":1}},{"line":144,"address":4833084,"length":1,"stats":{"Line":1}},{"line":147,"address":4833152,"length":1,"stats":{"Line":1}},{"line":148,"address":4833161,"length":1,"stats":{"Line":1}},{"line":151,"address":4833200,"length":1,"stats":{"Line":1}},{"line":152,"address":4833214,"length":1,"stats":{"Line":1}},{"line":153,"address":4833254,"length":1,"stats":{"Line":1}},{"line":155,"address":4833284,"length":1,"stats":{"Line":1}},{"line":161,"address":null,"length":0,"stats":{"Line":1}},{"line":162,"address":null,"length":0,"stats":{"Line":1}},{"line":171,"address":4280976,"length":1,"stats":{"Line":2}},{"line":172,"address":4846510,"length":1,"stats":{"Line":1}},{"line":173,"address":4846556,"length":1,"stats":{"Line":1}},{"line":174,"address":4846846,"length":1,"stats":{"Line":1}},{"line":175,"address":4847068,"length":1,"stats":{"Line":1}},{"line":176,"address":4847340,"length":1,"stats":{"Line":1}},{"line":177,"address":4847562,"length":1,"stats":{"Line":1}},{"line":178,"address":4847834,"length":1,"stats":{"Line":1}},{"line":179,"address":4848056,"length":1,"stats":{"Line":1}},{"line":180,"address":4848328,"length":1,"stats":{"Line":1}},{"line":181,"address":4848550,"length":1,"stats":{"Line":1}},{"line":182,"address":4848822,"length":1,"stats":{"Line":1}},{"line":183,"address":4849044,"length":1,"stats":{"Line":1}},{"line":184,"address":4849304,"length":1,"stats":{"Line":1}},{"line":185,"address":4849496,"length":1,"stats":{"Line":1}},{"line":189,"address":4281008,"length":1,"stats":{"Line":2}},{"line":190,"address":4849982,"length":1,"stats":{"Line":1}},{"line":191,"address":4850022,"length":1,"stats":{"Line":1}},{"line":192,"address":4850034,"length":1,"stats":{"Line":1}},{"line":193,"address":4850058,"length":1,"stats":{"Line":1}},{"line":197,"address":4281040,"length":1,"stats":{"Line":2}},{"line":198,"address":4850526,"length":1,"stats":{"Line":1}},{"line":199,"address":4850564,"length":1,"stats":{"Line":1}},{"line":200,"address":4850864,"length":1,"stats":{"Line":1}},{"line":204,"address":4281072,"length":1,"stats":{"Line":2}},{"line":205,"address":4851534,"length":1,"stats":{"Line":1}},{"line":206,"address":4851572,"length":1,"stats":{"Line":1}},{"line":207,"address":4851872,"length":1,"stats":{"Line":1}},{"line":211,"address":4281104,"length":1,"stats":{"Line":2}},{"line":212,"address":4852542,"length":1,"stats":{"Line":1}},{"line":213,"address":4852587,"length":1,"stats":{"Line":1}},{"line":217,"address":4281136,"length":1,"stats":{"Line":2}},{"line":218,"address":4853054,"length":1,"stats":{"Line":1}},{"line":219,"address":4853100,"length":1,"stats":{"Line":1}},{"line":220,"address":4853384,"length":1,"stats":{"Line":1}},{"line":221,"address":4853606,"length":1,"stats":{"Line":1}},{"line":222,"address":4853872,"length":1,"stats":{"Line":1}},{"line":223,"address":4854094,"length":1,"stats":{"Line":1}},{"line":224,"address":4854360,"length":1,"stats":{"Line":1}},{"line":225,"address":4854570,"length":1,"stats":{"Line":1}},{"line":226,"address":4854824,"length":1,"stats":{"Line":1}},{"line":227,"address":4855016,"length":1,"stats":{"Line":1}},{"line":231,"address":4281168,"length":1,"stats":{"Line":2}},{"line":232,"address":4855502,"length":1,"stats":{"Line":1}},{"line":233,"address":4855548,"length":1,"stats":{"Line":1}},{"line":234,"address":4855832,"length":1,"stats":{"Line":1}},{"line":235,"address":4856054,"length":1,"stats":{"Line":1}},{"line":236,"address":4856320,"length":1,"stats":{"Line":1}},{"line":237,"address":4856542,"length":1,"stats":{"Line":1}},{"line":238,"address":4856808,"length":1,"stats":{"Line":1}},{"line":239,"address":4857030,"length":1,"stats":{"Line":1}},{"line":240,"address":4857296,"length":1,"stats":{"Line":1}},{"line":241,"address":4857512,"length":1,"stats":{"Line":1}},{"line":242,"address":4857766,"length":1,"stats":{"Line":1}},{"line":246,"address":4281200,"length":1,"stats":{"Line":2}},{"line":247,"address":4858437,"length":1,"stats":{"Line":1}},{"line":248,"address":4858498,"length":1,"stats":{"Line":1}},{"line":249,"address":4858510,"length":1,"stats":{"Line":1}},{"line":250,"address":4858534,"length":1,"stats":{"Line":1}},{"line":251,"address":4858554,"length":1,"stats":{"Line":1}},{"line":255,"address":4281232,"length":1,"stats":{"Line":2}},{"line":256,"address":4859253,"length":1,"stats":{"Line":1}},{"line":257,"address":4859314,"length":1,"stats":{"Line":1}},{"line":261,"address":4281264,"length":1,"stats":{"Line":2}},{"line":262,"address":4859845,"length":1,"stats":{"Line":1}},{"line":263,"address":4859893,"length":1,"stats":{"Line":1}},{"line":265,"address":4859968,"length":1,"stats":{"Line":1}}],"covered":122,"coverable":124},{"path":["/","volume","src","value.rs"],"content":"use im::HashMap;\r\n\r\nuse crate::core_lib::Native;\r\n\r\n#[derive(Debug, PartialEq, Clone, Copy)]\r\npub enum Value {\r\n    Nothing,\r\n    Number(f64),\r\n    NativeFunction(Native),\r\n    True,\r\n    False,\r\n}\r\n\r\nimpl Value {\r\n    pub fn to_string(\u0026self) -\u003e String {\r\n        match self {\r\n            Value::Number(i) =\u003e format!(\"{}\", i),\r\n            Value::Nothing =\u003e \"Nothing\".to_string(),\r\n            Value::NativeFunction(_) =\u003e \"BuiltIn function\".to_string(),\r\n            Value::True =\u003e \"True\".to_string(),\r\n            Value::False =\u003e \"False\".to_string(),\r\n        }\r\n    }\r\n\r\n    pub fn add(\u0026self, other:\u0026Value) -\u003e Value{\r\n        let values = (self, other);\r\n        match values {\r\n            (Value::Number(a), Value::Number(b)) =\u003e Value::Number(a + b),\r\n            _ =\u003e Value::Nothing\r\n        }\r\n    }\r\n    \r\n\r\n}\r\n\r\npub type Scope = HashMap\u003cString, Value\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn nothing_to_string() {\r\n        assert_eq!(Value::Nothing.to_string(), \"Nothing\")\r\n    }\r\n\r\n    #[test]\r\n    fn number_to_string() {\r\n        assert_eq!(Value::Number(42.0).to_string(), \"42\")\r\n    }\r\n\r\n    #[test]\r\n    fn function_to_string() {\r\n        assert_eq!(\r\n            Value::NativeFunction(Native::Print).to_string(),\r\n            \"BuiltIn function\"\r\n        )\r\n    }\r\n}\r\n","traces":[{"line":15,"address":4765856,"length":1,"stats":{"Line":1}},{"line":16,"address":4766087,"length":1,"stats":{"Line":1}},{"line":17,"address":4765871,"length":1,"stats":{"Line":1}},{"line":18,"address":4766101,"length":1,"stats":{"Line":1}},{"line":19,"address":4766128,"length":1,"stats":{"Line":1}},{"line":20,"address":4766155,"length":1,"stats":{"Line":0}},{"line":21,"address":4766182,"length":1,"stats":{"Line":0}},{"line":25,"address":4766224,"length":1,"stats":{"Line":0}},{"line":26,"address":4766238,"length":1,"stats":{"Line":0}},{"line":27,"address":4766354,"length":1,"stats":{"Line":0}},{"line":28,"address":4766258,"length":1,"stats":{"Line":0}},{"line":29,"address":4766356,"length":1,"stats":{"Line":0}},{"line":43,"address":4335616,"length":1,"stats":{"Line":2}},{"line":44,"address":4335630,"length":1,"stats":{"Line":1}},{"line":48,"address":4336096,"length":1,"stats":{"Line":2}},{"line":49,"address":4336110,"length":1,"stats":{"Line":1}},{"line":53,"address":4336576,"length":1,"stats":{"Line":2}},{"line":54,"address":4336625,"length":1,"stats":{"Line":1}},{"line":55,"address":4336590,"length":1,"stats":{"Line":1}}],"covered":12,"coverable":19}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>