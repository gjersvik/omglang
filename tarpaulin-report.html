<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","volume","src","core_lib.rs"],"content":"use super::runtime::{scope::Scope, value::Value};\r\n\r\nuse std::{iter::FromIterator, sync::Arc};\r\n\r\nfn print(args: \u0026[Value]) -\u003e Value {\r\n    let string = Vec::from_iter(args.iter().map(|v| v.to_string())).join(\" \");\r\n    println!(\"{}\", string);\r\n    Value::Nothing\r\n}\r\n\r\npub fn global() -\u003e Arc\u003cScope\u003e {\r\n    let mut scope = Scope::new();\r\n    scope.set(\r\n        \"print\".to_string(),\r\n        Arc::new(Value::Function(Box::new(Arc::new(print)))),\r\n    );\r\n    Arc::new(scope)\r\n}\r\n","traces":[{"line":5,"address":4784608,"length":1,"stats":{"Line":0}},{"line":6,"address":4390768,"length":1,"stats":{"Line":0}},{"line":7,"address":4784832,"length":1,"stats":{"Line":0}},{"line":8,"address":4784977,"length":1,"stats":{"Line":0}},{"line":11,"address":4785056,"length":1,"stats":{"Line":0}},{"line":12,"address":4785063,"length":1,"stats":{"Line":0}},{"line":13,"address":4785282,"length":1,"stats":{"Line":0}},{"line":14,"address":4785114,"length":1,"stats":{"Line":0}},{"line":15,"address":4785146,"length":1,"stats":{"Line":0}},{"line":17,"address":4785320,"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","volume","src","error.rs"],"content":"use std::fmt;\r\n\r\n#[derive(Debug)]\r\npub struct OmgError {\r\n    pub msg: String,\r\n    pub pos: Position,\r\n}\r\n\r\nimpl OmgError {\r\n    pub fn new(msg: String, pos: Position) -\u003e Self {\r\n        OmgError { msg, pos }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for OmgError {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        writeln!(f, \"{}: {}\", self.pos, self.msg)\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\npub struct Position {\r\n    pub src: String,\r\n    pub line: u64,\r\n    pub column: u64,\r\n}\r\n\r\nimpl Position {\r\n    pub fn new(src: String, line: u64, column: u64) -\u003e Self {\r\n        Position { src, line, column }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Position {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}:{}:{}\", self.src, self.line, self.column)\r\n    }\r\n}\r\n\r\npub type Result\u003cT\u003e = std::result::Result\u003cT, OmgError\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn position() {\r\n        let pos = Position::new(\"test.omg\".to_owned(), 1, 2);\r\n        let display = format!(\"{}\", pos);\r\n        assert_eq!(display, \"test.omg:1:2\");\r\n    }\r\n\r\n    #[test]\r\n    fn omg_error() {\r\n        let pos = Position::new(\"test.omg\".to_owned(), 1, 2);\r\n        let error = OmgError::new(\"Test error\".to_owned(), pos);\r\n        let display = format!(\"{}\", error);\r\n        assert_eq!(display, \"test.omg:1:2: Test error\\n\");\r\n    }\r\n}\r\n","traces":[{"line":10,"address":4346192,"length":1,"stats":{"Line":1}},{"line":16,"address":4346336,"length":1,"stats":{"Line":1}},{"line":17,"address":4346353,"length":1,"stats":{"Line":1}},{"line":29,"address":4346624,"length":1,"stats":{"Line":1}},{"line":35,"address":4346720,"length":1,"stats":{"Line":1}},{"line":36,"address":4346737,"length":1,"stats":{"Line":1}},{"line":47,"address":4316640,"length":1,"stats":{"Line":2}},{"line":48,"address":4316798,"length":1,"stats":{"Line":1}},{"line":49,"address":4316863,"length":1,"stats":{"Line":1}},{"line":50,"address":4317040,"length":1,"stats":{"Line":1}},{"line":54,"address":4316672,"length":1,"stats":{"Line":2}},{"line":55,"address":4317550,"length":1,"stats":{"Line":1}},{"line":56,"address":4317632,"length":1,"stats":{"Line":1}},{"line":57,"address":4317745,"length":1,"stats":{"Line":1}},{"line":58,"address":4317925,"length":1,"stats":{"Line":1}}],"covered":15,"coverable":15},{"path":["/","volume","src","lib.rs"],"content":"#![warn(clippy::all)]\r\nmod core_lib;\r\nmod error;\r\nmod parser;\r\nmod runtime;\r\nmod tokens;\r\n\r\nuse error::{Position, Result};\r\nuse parser::parse_block;\r\nuse runtime::Runtime;\r\nuse tokens::Tokens;\r\n\r\nuse std::fs;\r\n\r\npub use error::OmgError;\r\n\r\npub fn run_file(file: \u0026str) -\u003e Result\u003c()\u003e {\r\n    let source = load_file(\u0026file)?;\r\n    let mut tokens = Tokens::lex(\u0026source, file.to_string())?;\r\n    let exp = parse_block(\u0026mut tokens);\r\n    let mut runtime = Runtime::new();\r\n    runtime.run(\u0026exp);\r\n    Ok(())\r\n}\r\n\r\nfn load_file(file: \u0026str) -\u003e Result\u003cString\u003e {\r\n    match fs::read_to_string(file) {\r\n        Ok(s) =\u003e Ok(s),\r\n        Err(err) =\u003e Err(OmgError::new(\r\n            err.to_string(),\r\n            Position::new(file.to_string(), 0, 0),\r\n        )),\r\n    }\r\n}\r\n","traces":[{"line":17,"address":4299856,"length":1,"stats":{"Line":0}},{"line":18,"address":4299876,"length":1,"stats":{"Line":0}},{"line":19,"address":4300350,"length":1,"stats":{"Line":0}},{"line":20,"address":4301202,"length":1,"stats":{"Line":0}},{"line":21,"address":4300884,"length":1,"stats":{"Line":0}},{"line":22,"address":4300915,"length":1,"stats":{"Line":0}},{"line":23,"address":4300972,"length":1,"stats":{"Line":0}},{"line":26,"address":4301360,"length":1,"stats":{"Line":0}},{"line":27,"address":4301380,"length":1,"stats":{"Line":0}},{"line":28,"address":4301478,"length":1,"stats":{"Line":0}},{"line":29,"address":4301647,"length":1,"stats":{"Line":0}},{"line":30,"address":4301692,"length":1,"stats":{"Line":0}},{"line":31,"address":4301707,"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","volume","src","parser.rs"],"content":"use crate::tokens::{TokenType, Tokens};\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum Exp {\r\n    Block(Vec\u003cExp\u003e),\r\n    Call(String, Vec\u003cExp\u003e),\r\n    LiteralUInt(u64),\r\n    InValid,\r\n}\r\n\r\npub fn parse_block(tokens: \u0026mut Tokens) -\u003e Exp {\r\n    let mut expressions = Vec::new();\r\n    loop {\r\n        let exp = parse(tokens);\r\n        if exp == Exp::InValid {\r\n            break;\r\n        }\r\n        tokens.next();\r\n        let t = tokens.current();\r\n        if t.token_type == TokenType::Semicolon {\r\n            expressions.push(exp);\r\n            tokens.next();\r\n        }\r\n    }\r\n    Exp::Block(expressions)\r\n}\r\n\r\npub fn parse(tokens: \u0026mut Tokens) -\u003e Exp {\r\n    let token = tokens.current();\r\n\r\n    match token.token_type {\r\n        TokenType::Identifier =\u003e {\r\n            let name = token.slice.to_string();\r\n            tokens.next();\r\n            if tokens.current().token_type != TokenType::ParenthesesOpen {\r\n                return Exp::InValid;\r\n            }\r\n            let mut args = Vec::new();\r\n            if !tokens.expect(TokenType::ParenthesesClose) {\r\n                loop {\r\n                    tokens.next();\r\n                    args.push(parse(tokens));\r\n                    tokens.next();\r\n                    match tokens.current().token_type {\r\n                        TokenType::ParenthesesClose =\u003e break,\r\n                        TokenType::Comma =\u003e (),\r\n                        _ =\u003e return Exp::InValid,\r\n                    };\r\n                }\r\n            }\r\n            Exp::Call(name, args)\r\n        }\r\n        TokenType::Number =\u003e Exp::LiteralUInt(token.slice.parse().unwrap()),\r\n        _ =\u003e Exp::InValid,\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn number() {\r\n        let mut tokens = Tokens::new_test(\"42\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(exp, Exp::LiteralUInt(42));\r\n    }\r\n\r\n    #[test]\r\n    fn call() {\r\n        let mut tokens = Tokens::new_test(\"print(42)\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(\r\n            exp,\r\n            Exp::Call(\"print\".to_string(), vec![Exp::LiteralUInt(42)])\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn call_two_args() {\r\n        let mut tokens = Tokens::new_test(\"print(1,2)\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(\r\n            exp,\r\n            Exp::Call(\r\n                \"print\".to_string(),\r\n                vec![Exp::LiteralUInt(1), Exp::LiteralUInt(2)]\r\n            )\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn call_no_open() {\r\n        let mut tokens = Tokens::new_test(\"print42)\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(exp, Exp::InValid);\r\n    }\r\n\r\n    #[test]\r\n    fn call_no_end() {\r\n        let mut tokens = Tokens::new_test(\"print(42\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(exp, Exp::InValid);\r\n    }\r\n\r\n    #[test]\r\n    fn block() {\r\n        let mut tokens = Tokens::new_test(\"42;\");\r\n        let exp = parse_block(\u0026mut tokens);\r\n        assert_eq!(exp, Exp::Block(vec![Exp::LiteralUInt(42)]));\r\n    }\r\n\r\n    #[test]\r\n    fn in_valid() {\r\n        let mut tokens = Tokens::new_test(\",\");\r\n        let exp = parse(\u0026mut tokens);\r\n        assert_eq!(exp, Exp::InValid);\r\n    }\r\n}\r\n","traces":[{"line":11,"address":4313504,"length":1,"stats":{"Line":1}},{"line":12,"address":4313519,"length":1,"stats":{"Line":1}},{"line":13,"address":4313965,"length":1,"stats":{"Line":1}},{"line":14,"address":4313567,"length":1,"stats":{"Line":1}},{"line":15,"address":4313604,"length":1,"stats":{"Line":1}},{"line":18,"address":4313657,"length":1,"stats":{"Line":1}},{"line":19,"address":4313777,"length":1,"stats":{"Line":1}},{"line":20,"address":4313807,"length":1,"stats":{"Line":1}},{"line":21,"address":4313850,"length":1,"stats":{"Line":1}},{"line":22,"address":4313933,"length":1,"stats":{"Line":1}},{"line":25,"address":4313677,"length":1,"stats":{"Line":1}},{"line":28,"address":4314080,"length":1,"stats":{"Line":1}},{"line":29,"address":4314095,"length":1,"stats":{"Line":1}},{"line":31,"address":4314772,"length":1,"stats":{"Line":1}},{"line":32,"address":4314140,"length":1,"stats":{"Line":1}},{"line":33,"address":4314197,"length":1,"stats":{"Line":1}},{"line":34,"address":4314219,"length":1,"stats":{"Line":1}},{"line":35,"address":4314231,"length":1,"stats":{"Line":1}},{"line":36,"address":4314308,"length":1,"stats":{"Line":1}},{"line":38,"address":4314325,"length":1,"stats":{"Line":1}},{"line":39,"address":4314357,"length":1,"stats":{"Line":1}},{"line":40,"address":4314558,"length":1,"stats":{"Line":1}},{"line":41,"address":4314422,"length":1,"stats":{"Line":1}},{"line":42,"address":4314434,"length":1,"stats":{"Line":1}},{"line":43,"address":4314477,"length":1,"stats":{"Line":1}},{"line":44,"address":4314489,"length":1,"stats":{"Line":1}},{"line":45,"address":4314511,"length":1,"stats":{"Line":1}},{"line":47,"address":4314568,"length":1,"stats":{"Line":1}},{"line":51,"address":4314595,"length":1,"stats":{"Line":1}},{"line":53,"address":4314774,"length":1,"stats":{"Line":1}},{"line":54,"address":4314845,"length":1,"stats":{"Line":1}},{"line":63,"address":4266896,"length":1,"stats":{"Line":2}},{"line":64,"address":4266910,"length":1,"stats":{"Line":1}},{"line":65,"address":4266955,"length":1,"stats":{"Line":1}},{"line":66,"address":4266967,"length":1,"stats":{"Line":1}},{"line":70,"address":4267472,"length":1,"stats":{"Line":2}},{"line":71,"address":4267486,"length":1,"stats":{"Line":1}},{"line":72,"address":4267531,"length":1,"stats":{"Line":1}},{"line":73,"address":4267797,"length":1,"stats":{"Line":1}},{"line":75,"address":4267538,"length":1,"stats":{"Line":1}},{"line":80,"address":4268352,"length":1,"stats":{"Line":2}},{"line":81,"address":4268366,"length":1,"stats":{"Line":1}},{"line":82,"address":4268411,"length":1,"stats":{"Line":1}},{"line":83,"address":4268749,"length":1,"stats":{"Line":1}},{"line":85,"address":4268668,"length":1,"stats":{"Line":1}},{"line":86,"address":4268418,"length":1,"stats":{"Line":1}},{"line":87,"address":4268467,"length":1,"stats":{"Line":1}},{"line":93,"address":4269312,"length":1,"stats":{"Line":2}},{"line":94,"address":4269326,"length":1,"stats":{"Line":1}},{"line":95,"address":4269371,"length":1,"stats":{"Line":1}},{"line":96,"address":4269383,"length":1,"stats":{"Line":1}},{"line":100,"address":4269888,"length":1,"stats":{"Line":2}},{"line":101,"address":4269902,"length":1,"stats":{"Line":1}},{"line":102,"address":4269947,"length":1,"stats":{"Line":1}},{"line":103,"address":4269959,"length":1,"stats":{"Line":1}},{"line":107,"address":4270464,"length":1,"stats":{"Line":2}},{"line":108,"address":4270478,"length":1,"stats":{"Line":1}},{"line":109,"address":4270523,"length":1,"stats":{"Line":1}},{"line":110,"address":4270540,"length":1,"stats":{"Line":1}},{"line":114,"address":4271248,"length":1,"stats":{"Line":2}},{"line":115,"address":4271262,"length":1,"stats":{"Line":1}},{"line":116,"address":4271307,"length":1,"stats":{"Line":1}},{"line":117,"address":4271319,"length":1,"stats":{"Line":1}}],"covered":63,"coverable":63},{"path":["/","volume","src","runtime","scope.rs"],"content":"use super::Value;\r\n\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\n\r\npub struct Scope {\r\n    values: HashMap\u003cString, Arc\u003cValue\u003e\u003e,\r\n    parent: Option\u003cArc\u003cScope\u003e\u003e,\r\n}\r\n\r\nimpl Scope {\r\n    pub fn new() -\u003e Scope {\r\n        Self::parent(Option::None)\r\n    }\r\n\r\n    pub fn parent(parent: Option\u003cArc\u003cScope\u003e\u003e) -\u003e Scope {\r\n        Scope {\r\n            values: HashMap::new(),\r\n            parent,\r\n        }\r\n    }\r\n\r\n    pub fn get(\u0026self, name: \u0026str) -\u003e Arc\u003cValue\u003e {\r\n        match self.values.get(name) {\r\n            Some(v) =\u003e v.clone(),\r\n            None =\u003e match \u0026self.parent {\r\n                Some(p) =\u003e p.get(name),\r\n                None =\u003e Arc::new(Value::Nothing),\r\n            },\r\n        }\r\n    }\r\n\r\n    pub fn set(\u0026mut self, name: String, value: Arc\u003cValue\u003e) {\r\n        self.values.insert(name, value);\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn get_missing() {\r\n        let scope = Scope::new();\r\n        assert_eq!(*scope.get(\"missing\"), Value::Nothing);\r\n    }\r\n\r\n    #[test]\r\n    fn set_get_value() {\r\n        let mut scope = Scope::new();\r\n        let value = Arc::new(Value::UInt(42));\r\n        scope.set(\"life\".to_string(), value.clone());\r\n\r\n        assert_eq!(scope.get(\"life\"), value);\r\n    }\r\n\r\n    #[test]\r\n    fn get_value_from_parent() {\r\n        let mut scope = Scope::new();\r\n        let value = Arc::new(Value::UInt(42));\r\n        scope.set(\"life\".to_string(), value.clone());\r\n        let scope = Scope::parent(Some(Arc::new(scope)));\r\n        assert_eq!(scope.get(\"life\"), value);\r\n    }\r\n\r\n    #[test]\r\n    fn get_missing_from_parent() {\r\n        let scope = Scope::new();\r\n        let scope = Scope::parent(Some(Arc::new(scope)));\r\n        assert_eq!(*scope.get(\"missing\"), Value::Nothing);\r\n    }\r\n\r\n    #[test]\r\n    fn local_overwrite_parent() {\r\n        let mut scope = Scope::new();\r\n        scope.set(\"life\".to_string(), Arc::new(Value::UInt(126)));\r\n        let mut scope = Scope::parent(Some(Arc::new(scope)));\r\n        let value = Arc::new(Value::UInt(42));\r\n        scope.set(\"life\".to_string(), value.clone());\r\n        assert_eq!(scope.get(\"life\"), value);\r\n    }\r\n}\r\n","traces":[{"line":12,"address":4261888,"length":1,"stats":{"Line":1}},{"line":13,"address":4261895,"length":1,"stats":{"Line":1}},{"line":16,"address":4261936,"length":1,"stats":{"Line":1}},{"line":18,"address":4261958,"length":1,"stats":{"Line":1}},{"line":23,"address":4262080,"length":1,"stats":{"Line":1}},{"line":24,"address":4262102,"length":1,"stats":{"Line":1}},{"line":25,"address":4262140,"length":1,"stats":{"Line":1}},{"line":26,"address":4262215,"length":1,"stats":{"Line":1}},{"line":27,"address":4262227,"length":1,"stats":{"Line":1}},{"line":28,"address":4262326,"length":1,"stats":{"Line":1}},{"line":33,"address":4262368,"length":1,"stats":{"Line":1}},{"line":34,"address":4262382,"length":1,"stats":{"Line":1}},{"line":43,"address":4294848,"length":1,"stats":{"Line":2}},{"line":44,"address":4294855,"length":1,"stats":{"Line":1}},{"line":45,"address":4294882,"length":1,"stats":{"Line":1}},{"line":49,"address":4295456,"length":1,"stats":{"Line":2}},{"line":50,"address":4295463,"length":1,"stats":{"Line":1}},{"line":51,"address":4295498,"length":1,"stats":{"Line":1}},{"line":52,"address":4295567,"length":1,"stats":{"Line":1}},{"line":54,"address":4295678,"length":1,"stats":{"Line":1}},{"line":58,"address":4296336,"length":1,"stats":{"Line":2}},{"line":59,"address":4296343,"length":1,"stats":{"Line":1}},{"line":60,"address":4296394,"length":1,"stats":{"Line":1}},{"line":61,"address":4296451,"length":1,"stats":{"Line":1}},{"line":62,"address":4296565,"length":1,"stats":{"Line":1}},{"line":63,"address":4296668,"length":1,"stats":{"Line":1}},{"line":67,"address":4297408,"length":1,"stats":{"Line":2}},{"line":68,"address":4297415,"length":1,"stats":{"Line":1}},{"line":69,"address":4297442,"length":1,"stats":{"Line":1}},{"line":70,"address":4297528,"length":1,"stats":{"Line":1}},{"line":74,"address":4298112,"length":1,"stats":{"Line":2}},{"line":75,"address":4298119,"length":1,"stats":{"Line":1}},{"line":76,"address":4298178,"length":1,"stats":{"Line":1}},{"line":77,"address":4298298,"length":1,"stats":{"Line":1}},{"line":78,"address":4298404,"length":1,"stats":{"Line":1}},{"line":79,"address":4298461,"length":1,"stats":{"Line":1}},{"line":80,"address":4298593,"length":1,"stats":{"Line":1}}],"covered":37,"coverable":37},{"path":["/","volume","src","runtime","value.rs"],"content":"use std::{cmp, fmt, sync::Arc};\r\n\r\n#[derive(Debug, PartialEq)]\r\npub enum Value {\r\n    Nothing,\r\n    UInt(u64),\r\n    Function(Box\u003cArc\u003cOmgFn\u003e\u003e),\r\n}\r\n\r\nimpl Value {\r\n    pub fn to_string(\u0026self) -\u003e String {\r\n        match self {\r\n            Value::UInt(i) =\u003e format!(\"{}\", i),\r\n            Value::Nothing =\u003e \"Nothing\".to_string(),\r\n            Value::Function(_) =\u003e \"BuiltIn function\".to_string(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait OmgFnTr: Fn(\u0026[Value]) -\u003e Value {}\r\nimpl\u003cF\u003e OmgFnTr for F where F: Fn(\u0026[Value]) -\u003e Value + Copy {}\r\npub type OmgFn = dyn OmgFnTr\u003cOutput = Value\u003e;\r\n\r\n#[cfg_attr(tarpaulin, skip)]\r\nimpl fmt::Debug for OmgFn {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"OmgFn\")\r\n    }\r\n}\r\n\r\n#[cfg_attr(tarpaulin, skip)]\r\nimpl cmp::PartialEq for OmgFn {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        self == other\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[cfg_attr(tarpaulin, skip)]\r\n    fn noop(_: \u0026[Value]) -\u003e Value {\r\n        Value::Nothing\r\n    }\r\n\r\n    #[test]\r\n    fn nothing_to_string() {\r\n        assert_eq!(Value::Nothing.to_string(), \"Nothing\")\r\n    }\r\n\r\n    #[test]\r\n    fn int_to_string() {\r\n        assert_eq!(Value::UInt(42).to_string(), \"42\")\r\n    }\r\n\r\n    #[test]\r\n    fn function_to_string() {\r\n        assert_eq!(\r\n            Value::Function(Box::new(Arc::new(noop))).to_string(),\r\n            \"BuiltIn function\"\r\n        )\r\n    }\r\n}\r\n","traces":[{"line":11,"address":4366352,"length":1,"stats":{"Line":1}},{"line":12,"address":4366607,"length":1,"stats":{"Line":1}},{"line":13,"address":4366367,"length":1,"stats":{"Line":1}},{"line":14,"address":4366621,"length":1,"stats":{"Line":1}},{"line":15,"address":4366648,"length":1,"stats":{"Line":1}},{"line":48,"address":4262464,"length":1,"stats":{"Line":2}},{"line":49,"address":4390862,"length":1,"stats":{"Line":1}},{"line":53,"address":4262496,"length":1,"stats":{"Line":2}},{"line":54,"address":4391342,"length":1,"stats":{"Line":1}},{"line":58,"address":4262528,"length":1,"stats":{"Line":2}},{"line":59,"address":4391975,"length":1,"stats":{"Line":1}},{"line":60,"address":4391815,"length":1,"stats":{"Line":1}}],"covered":12,"coverable":12},{"path":["/","volume","src","runtime.rs"],"content":"pub mod scope;\r\npub mod value;\r\n\r\nuse super::{core_lib::global, parser::Exp};\r\nuse scope::Scope;\r\nuse value::Value;\r\n\r\nuse std::iter::FromIterator;\r\n\r\npub struct Runtime {\r\n    local: Scope,\r\n}\r\n\r\nimpl Runtime {\r\n    pub fn new() -\u003e Runtime {\r\n        let g = global();\r\n        Runtime {\r\n            local: Scope::parent(Some(g)),\r\n        }\r\n    }\r\n\r\n    pub fn run(\u0026mut self, exp: \u0026Exp) -\u003e Value {\r\n        self.run_exp(exp)\r\n    }\r\n\r\n    fn run_exp(\u0026mut self, exp: \u0026Exp) -\u003e Value {\r\n        match exp {\r\n            Exp::Call(i, args) =\u003e {\r\n                let v = self.local.get(i);\r\n                match *v {\r\n                    Value::Function(ref function) =\u003e function(\u0026self.run_list(args)),\r\n                    _ =\u003e panic!(\"Cant find function named {} to call\", i),\r\n                }\r\n            }\r\n            Exp::Block(block) =\u003e {\r\n                self.run_list(\u0026block);\r\n                Value::Nothing\r\n            }\r\n            Exp::LiteralUInt(int) =\u003e Value::UInt(*int),\r\n            Exp::InValid =\u003e panic!(\"Invalid expression found.\"),\r\n        }\r\n    }\r\n\r\n    fn run_list(\u0026mut self, expressions: \u0026[Exp]) -\u003e Vec\u003cValue\u003e {\r\n        let iter = expressions.iter().map(|exp| self.run_exp(exp));\r\n        Vec::from_iter(iter)\r\n    }\r\n}\r\n","traces":[{"line":15,"address":4292480,"length":1,"stats":{"Line":0}},{"line":16,"address":4292497,"length":1,"stats":{"Line":0}},{"line":18,"address":4292507,"length":1,"stats":{"Line":0}},{"line":22,"address":4292576,"length":1,"stats":{"Line":0}},{"line":23,"address":4292593,"length":1,"stats":{"Line":0}},{"line":26,"address":4292624,"length":1,"stats":{"Line":0}},{"line":27,"address":4293370,"length":1,"stats":{"Line":0}},{"line":28,"address":4292650,"length":1,"stats":{"Line":0}},{"line":29,"address":4292783,"length":1,"stats":{"Line":0}},{"line":30,"address":4292873,"length":1,"stats":{"Line":0}},{"line":31,"address":4292890,"length":1,"stats":{"Line":0}},{"line":32,"address":4293218,"length":1,"stats":{"Line":0}},{"line":35,"address":4293375,"length":1,"stats":{"Line":0}},{"line":36,"address":4293395,"length":1,"stats":{"Line":0}},{"line":37,"address":4293478,"length":1,"stats":{"Line":0}},{"line":39,"address":4293487,"length":1,"stats":{"Line":0}},{"line":40,"address":4293539,"length":1,"stats":{"Line":0}},{"line":44,"address":4293632,"length":1,"stats":{"Line":0}},{"line":45,"address":4293654,"length":1,"stats":{"Line":0}},{"line":46,"address":4293727,"length":1,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","volume","src","tokens.rs"],"content":"use crate::error::{Position, Result};\r\n\r\nuse logos::{Extras, Logos};\r\n\r\n#[derive(Default)]\r\npub struct TokenExtra {\r\n    line: u64,\r\n    column: u64,\r\n}\r\n\r\nimpl Extras for TokenExtra {\r\n    fn on_advance(\u0026mut self) {}\r\n\r\n    fn on_whitespace(\u0026mut self, byte: u8) {\r\n        if byte == 10 {\r\n            self.line += 1;\r\n            self.column = 0;\r\n        } else {\r\n            self.column += 1;\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Logos, Debug, Clone, Copy, PartialEq)]\r\n#[extras = \"TokenExtra\"]\r\npub enum TokenType {\r\n    #[end]\r\n    End,\r\n\r\n    #[error]\r\n    Error,\r\n\r\n    #[regex = \"[a-zA-Z_][a-zA-Z0-9_]*\"]\r\n    Identifier,\r\n\r\n    #[regex = \"\\\\d+\"]\r\n    Number,\r\n\r\n    #[token = \"(\"]\r\n    ParenthesesOpen,\r\n\r\n    #[token = \")\"]\r\n    ParenthesesClose,\r\n\r\n    #[token = \",\"]\r\n    Comma,\r\n\r\n    #[token = \";\"]\r\n    Semicolon,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Token\u003c'a\u003e {\r\n    pub token_type: TokenType,\r\n    pub slice: \u0026'a str,\r\n    pub line: u64,\r\n    pub column: u64,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Tokens\u003c'a\u003e {\r\n    tokens: Vec\u003cToken\u003c'a\u003e\u003e,\r\n    index: usize,\r\n    file: String,\r\n}\r\n\r\nimpl\u003c'a\u003e Tokens\u003c'a\u003e {\r\n    pub fn lex(code: \u0026'a str, file: String) -\u003e Result\u003cSelf\u003e {\r\n        let mut tokens = Vec::new();\r\n        let mut lexer = TokenType::lexer(code);\r\n        loop {\r\n            tokens.push(Token {\r\n                token_type: lexer.token,\r\n                slice: lexer.slice(),\r\n                line: lexer.extras.line,\r\n                column: lexer.extras.column,\r\n            });\r\n            if lexer.token == TokenType::End {\r\n                break;\r\n            }\r\n            lexer.extras.column += lexer.slice().len() as u64;\r\n            lexer.advance();\r\n        }\r\n\r\n        Ok(Tokens {\r\n            tokens,\r\n            index: 0,\r\n            file,\r\n        })\r\n    }\r\n\r\n    pub fn next(\u0026mut self) {\r\n        self.index += 1;\r\n        if self.index \u003e= self.tokens.len() {\r\n            self.index = self.tokens.len() - 1;\r\n        }\r\n    }\r\n\r\n    pub fn expect(\u0026mut self, token_type: TokenType) -\u003e bool {\r\n        if self.get(self.index + 1).token_type == token_type {\r\n            self.next();\r\n            return true;\r\n        }\r\n        false\r\n    }\r\n\r\n    pub fn current(\u0026self) -\u003e \u0026Token {\r\n        \u0026self.tokens[self.index]\r\n    }\r\n\r\n    pub fn position(\u0026self) -\u003e Position {\r\n        let token = self.current();\r\n        Position::new(self.file.to_string(), token.line, token.column)\r\n    }\r\n\r\n    fn get(\u0026self, index: usize) -\u003e \u0026Token {\r\n        if index \u003e= self.tokens.len() {\r\n            return \u0026self.tokens[self.tokens.len() - 1];\r\n        }\r\n        \u0026self.tokens[index]\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nimpl\u003c'a\u003e Tokens\u003c'a\u003e {\r\n    pub fn new_test(code: \u0026'a str) -\u003e Self {\r\n        Tokens::lex(code, \"test_code\".to_string()).expect(\"Failed to tokenize test_data.\")\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn one_of_each() {\r\n        let mut tokens = Tokens::new_test(\"test 42 ( ) , ;\");\r\n        assert_eq!(tokens.current().token_type, TokenType::Identifier);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Number);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::ParenthesesOpen);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::ParenthesesClose);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Comma);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::Semicolon);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn go_pass_end() {\r\n        let mut tokens = Tokens::new_test(\"42\");\r\n        tokens.next(); // At end.\r\n        tokens.next(); // over the end.\r\n        assert_eq!(tokens.current().token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn expect_true() {\r\n        let mut tokens = Tokens::new_test(\"test 42\");\r\n        assert_eq!(tokens.expect(TokenType::Number), true);\r\n        assert_eq!(tokens.current().token_type, TokenType::Number);\r\n    }\r\n\r\n    #[test]\r\n    fn expect_false() {\r\n        let mut tokens = Tokens::new_test(\"test 42\");\r\n        assert_eq!(tokens.expect(TokenType::Semicolon), false);\r\n        assert_eq!(tokens.current().token_type, TokenType::Identifier);\r\n    }\r\n\r\n    #[test]\r\n    fn get_pass_end() {\r\n        let tokens = Tokens::new_test(\"42\");\r\n        assert_eq!(tokens.get(2).token_type, TokenType::End);\r\n    }\r\n\r\n    #[test]\r\n    fn track_column() {\r\n        let mut tokens = Tokens::new_test(\"test 2 3 4\");\r\n        assert_eq!(tokens.current().column, 0);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().column, 5);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().column, 7);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().column, 9);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().column, 10);\r\n    }\r\n\r\n    #[test]\r\n    fn track_line() {\r\n        let mut tokens = Tokens::new_test(\"test 2\\r\\n3 4\");\r\n        assert_eq!(tokens.current().line, 0);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().line, 0);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().line, 1);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().line, 1);\r\n        tokens.next();\r\n        assert_eq!(tokens.current().line, 1);\r\n        assert_eq!(tokens.current().column, 3);\r\n    }\r\n\r\n    #[test]\r\n    fn position() {\r\n        let mut tokens = Tokens::lex(\"test 2\\r\\n3 4\", \"test.omg\".to_owned()).unwrap();\r\n        tokens.next();\r\n        tokens.next();\r\n        tokens.next();\r\n        assert_eq!(\r\n            tokens.position(),\r\n            Position::new(\"test.omg\".to_owned(), 1, 2)\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":12,"address":4262560,"length":1,"stats":{"Line":1}},{"line":14,"address":4262576,"length":1,"stats":{"Line":1}},{"line":15,"address":4262592,"length":1,"stats":{"Line":1}},{"line":16,"address":4262599,"length":1,"stats":{"Line":1}},{"line":17,"address":4262667,"length":1,"stats":{"Line":1}},{"line":18,"address":null,"length":0,"stats":{"Line":0}},{"line":19,"address":4262626,"length":1,"stats":{"Line":1}},{"line":68,"address":4262752,"length":1,"stats":{"Line":1}},{"line":69,"address":4262772,"length":1,"stats":{"Line":1}},{"line":70,"address":4262841,"length":1,"stats":{"Line":1}},{"line":71,"address":4262874,"length":1,"stats":{"Line":1}},{"line":72,"address":4262950,"length":1,"stats":{"Line":1}},{"line":73,"address":4262876,"length":1,"stats":{"Line":1}},{"line":74,"address":4262895,"length":1,"stats":{"Line":1}},{"line":75,"address":4262930,"length":1,"stats":{"Line":1}},{"line":76,"address":4262938,"length":1,"stats":{"Line":1}},{"line":78,"address":4263019,"length":1,"stats":{"Line":1}},{"line":79,"address":null,"length":0,"stats":{"Line":0}},{"line":81,"address":4263287,"length":1,"stats":{"Line":1}},{"line":82,"address":4263375,"length":1,"stats":{"Line":1}},{"line":85,"address":4263128,"length":1,"stats":{"Line":1}},{"line":86,"address":4263058,"length":1,"stats":{"Line":1}},{"line":87,"address":null,"length":0,"stats":{"Line":0}},{"line":88,"address":4263092,"length":1,"stats":{"Line":1}},{"line":92,"address":4263568,"length":1,"stats":{"Line":1}},{"line":93,"address":4263577,"length":1,"stats":{"Line":1}},{"line":94,"address":4263616,"length":1,"stats":{"Line":1}},{"line":95,"address":4263663,"length":1,"stats":{"Line":1}},{"line":99,"address":4263760,"length":1,"stats":{"Line":1}},{"line":100,"address":4263776,"length":1,"stats":{"Line":1}},{"line":101,"address":4263867,"length":1,"stats":{"Line":1}},{"line":102,"address":4263886,"length":1,"stats":{"Line":1}},{"line":104,"address":4263879,"length":1,"stats":{"Line":1}},{"line":107,"address":4263936,"length":1,"stats":{"Line":1}},{"line":108,"address":4263945,"length":1,"stats":{"Line":1}},{"line":111,"address":4263984,"length":1,"stats":{"Line":1}},{"line":112,"address":4263996,"length":1,"stats":{"Line":1}},{"line":113,"address":4264023,"length":1,"stats":{"Line":1}},{"line":116,"address":4264096,"length":1,"stats":{"Line":1}},{"line":117,"address":4264110,"length":1,"stats":{"Line":1}},{"line":118,"address":4264150,"length":1,"stats":{"Line":1}},{"line":120,"address":4264180,"length":1,"stats":{"Line":1}},{"line":126,"address":null,"length":0,"stats":{"Line":1}},{"line":127,"address":null,"length":0,"stats":{"Line":1}},{"line":136,"address":4274960,"length":1,"stats":{"Line":2}},{"line":137,"address":4809726,"length":1,"stats":{"Line":1}},{"line":138,"address":4809772,"length":1,"stats":{"Line":1}},{"line":139,"address":4810062,"length":1,"stats":{"Line":1}},{"line":140,"address":4810284,"length":1,"stats":{"Line":1}},{"line":141,"address":4810556,"length":1,"stats":{"Line":1}},{"line":142,"address":4810778,"length":1,"stats":{"Line":1}},{"line":143,"address":4811050,"length":1,"stats":{"Line":1}},{"line":144,"address":4811272,"length":1,"stats":{"Line":1}},{"line":145,"address":4811544,"length":1,"stats":{"Line":1}},{"line":146,"address":4811766,"length":1,"stats":{"Line":1}},{"line":147,"address":4812038,"length":1,"stats":{"Line":1}},{"line":148,"address":4812260,"length":1,"stats":{"Line":1}},{"line":149,"address":4812514,"length":1,"stats":{"Line":1}},{"line":150,"address":4812706,"length":1,"stats":{"Line":1}},{"line":154,"address":4274992,"length":1,"stats":{"Line":2}},{"line":155,"address":4813198,"length":1,"stats":{"Line":1}},{"line":156,"address":4813238,"length":1,"stats":{"Line":1}},{"line":157,"address":4813250,"length":1,"stats":{"Line":1}},{"line":158,"address":4813274,"length":1,"stats":{"Line":1}},{"line":162,"address":4275024,"length":1,"stats":{"Line":2}},{"line":163,"address":4813758,"length":1,"stats":{"Line":1}},{"line":164,"address":4813793,"length":1,"stats":{"Line":1}},{"line":165,"address":4814084,"length":1,"stats":{"Line":1}},{"line":169,"address":4275056,"length":1,"stats":{"Line":2}},{"line":170,"address":4814750,"length":1,"stats":{"Line":1}},{"line":171,"address":4814785,"length":1,"stats":{"Line":1}},{"line":172,"address":4815076,"length":1,"stats":{"Line":1}},{"line":176,"address":4275088,"length":1,"stats":{"Line":2}},{"line":177,"address":4815742,"length":1,"stats":{"Line":1}},{"line":178,"address":4815787,"length":1,"stats":{"Line":1}},{"line":182,"address":4275120,"length":1,"stats":{"Line":2}},{"line":183,"address":4816286,"length":1,"stats":{"Line":1}},{"line":184,"address":4816332,"length":1,"stats":{"Line":1}},{"line":185,"address":4816612,"length":1,"stats":{"Line":1}},{"line":186,"address":4816834,"length":1,"stats":{"Line":1}},{"line":187,"address":4817096,"length":1,"stats":{"Line":1}},{"line":188,"address":4817318,"length":1,"stats":{"Line":1}},{"line":189,"address":4817580,"length":1,"stats":{"Line":1}},{"line":190,"address":4817796,"length":1,"stats":{"Line":1}},{"line":191,"address":4818046,"length":1,"stats":{"Line":1}},{"line":192,"address":4818238,"length":1,"stats":{"Line":1}},{"line":196,"address":4275152,"length":1,"stats":{"Line":2}},{"line":197,"address":4818718,"length":1,"stats":{"Line":1}},{"line":198,"address":4818764,"length":1,"stats":{"Line":1}},{"line":199,"address":4819044,"length":1,"stats":{"Line":1}},{"line":200,"address":4819266,"length":1,"stats":{"Line":1}},{"line":201,"address":4819528,"length":1,"stats":{"Line":1}},{"line":202,"address":4819750,"length":1,"stats":{"Line":1}},{"line":203,"address":4820012,"length":1,"stats":{"Line":1}},{"line":204,"address":4820234,"length":1,"stats":{"Line":1}},{"line":205,"address":4820496,"length":1,"stats":{"Line":1}},{"line":206,"address":4820706,"length":1,"stats":{"Line":1}},{"line":207,"address":4820956,"length":1,"stats":{"Line":1}},{"line":211,"address":4275184,"length":1,"stats":{"Line":2}},{"line":212,"address":4821614,"length":1,"stats":{"Line":1}},{"line":213,"address":4821705,"length":1,"stats":{"Line":1}},{"line":214,"address":4821717,"length":1,"stats":{"Line":1}},{"line":215,"address":4821741,"length":1,"stats":{"Line":1}},{"line":216,"address":4821828,"length":1,"stats":{"Line":0}},{"line":217,"address":4821761,"length":1,"stats":{"Line":1}},{"line":218,"address":4821768,"length":1,"stats":{"Line":1}}],"covered":102,"coverable":106}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>